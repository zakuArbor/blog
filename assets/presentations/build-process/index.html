<!doctype html>
<html lang="en">

	<head>
<meta charset="utf-8">

<title>Build Education</title>

<meta name="description" content="Build Education - Generic Build Process">
<meta name="author" content="Ju Hong Kim">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="dist/reset.css">
<link rel="stylesheet" href="dist/reveal.css">
<link rel="stylesheet" href="dist/theme/black.css" id="theme">

<!-- Theme used for syntax highlighting of code -->
<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>

	<body>

<div class="reveal">

	<!-- Any section element inside of this container is displayed as a slide -->
	<div class="slides">
		<section>
			<h2>A Dive to the Build Process</h2>
			<p> 
				What Goes On When You Press the Play Button
			</p>
		</section>

		<section>
			<h2>Previously</h2>
			<p>
        A Build is the process of transforming code to an executable
      </p>
      <img src = "https://raw.githubusercontent.com/zakuArbor/blog/master/assets/programming/builds/highlevel-build.png"/>
		</section>
    <section>
      <h2>Today</h2>
			<p>
        We dive a bit deeper but not too deep
      </p>
      <img src = "https://raw.githubusercontent.com/zakuArbor/blog/master/assets/programming/builds/highlevel-build2.png"/>
      <aside class = "notes">
        Today, ...
        In fact, the content presented to you may already be something you've been exposed to or already know from your courses. 
        At least for me who has never taken a compiler course, being in this team exposed me to the build process in more detail.
        Of course, this is just going over the high overview of building code. I won't go into compiler design
        since I don't think that's important nor am I knowledable of the subject since I never taken a compiler course.
      </aside>
		</section>
     <section>
      <h2>GCC Build Process</h2>
			<p>
        Your compiler does more than compiling code
      </p>
      <img src = "https://upload.wikimedia.org/wikipedia/commons/9/9a/Preprocessor.png"/>
      <aside class = "notes">
        Anyhow, as I stated previously, your compiler does more than compilng code. There's a lot of steps that goes on in the build toolchain before and after the compilation stage
        such as the preproccessor, assembler, and linker. The diagram you are seeing is all the steps the gcc compiler performs.
      </aside>
		</section>
    <section>
      <section>
        <h2>Preprocessor</h2>
        <img src = "https://raw.githubusercontent.com/zakuArbor/blog/3629c04cab2406113320382858f05716a2eb0540/assets/programming/builds/gcc-preprocessor.png"/>
        <aside class = "notes">
          Let's go onto the first stage, the preprocessor. This is the first stage whenever you are trying to build your code into an executable.
          I like to refer this stage as expanding your source code before the compiler gets to see it.
        </aside>
      </section>
      <section>
        <h2>Expands Source Code</h2>
        <p>
          Gives ability to:
          <small>
          <ul>
            <li>include header files</li>
            <li>macro expansion: object-like (i.e. constants) and function-like</li>
            <li>conditional compilation</li>
          </ul>
          </small>
        </p>
        <pre><code class = "h"></code>
          #ifndef MATH_H
          #define MATH_H
          #include &lt;stdio.h&gt;
          #define PI 3.14
          #ifdef __LINUX__
            #include "linux.h"
          #elif __WIN__
            #inclide "windows.h"
          #endif
        </code></pre>
        <aside class = "notes">
          The preprocessor gives the ability to include headerfiles, perform macro expansion, and gives the ability to have conditional compilation. Here's an example of a macro.
        </aside>
      </section>
      <section>
        <h3>Preprocessor - MACRO</h3>
        <aside class = "notes">I assume you know what a macro is but I'll just quickly go over it just in case.</aside>
      </section>
      <section>
        <h3>- substitute text -</h3>
        <small><b>RECALL:</b> In C89, there is no variable length array support</small>
        <pre><code class = "cpp">
          int max_buffer_size = 10;
          int arr[max_buffer_size];
        </code></pre>
        <h3><u>THIS IS ILLEGAL</u></h3>
        <aside class="notes">
          essentially, macros substitute text. Let's say we want to have an array whose size is determined by some value which in this case is a variable. 
          Recall .. So this code is illegal in C. You cannot dynamically 
          assign the size of an array using a variable. 
        </aside>
      </section>
      <section>
        <h2>Solution</h2>
        <p>- Use a MACRO - </p>
        <aside class="notes">
          So the solution to this is to simply use a macro.
        </aside>
      </section>
      <section>
        <pre><code class = "cpp">
          # define MAX_BUFFER_SIZE 10
          int main() {
            int arr[MAX_BUFFER_SIZE];
            // Rest of the code
        </code></pre>
        <pre><code class = "cpp">
          int main() {
            int arr[10];
            //Rest of the code
        </code></pre> 
        <aside class="notes">
          On the top, you can see the code has been changed to use a macro named ... with the value ... and assign the array size with MAX_BUFFER_SIZE. When we compile the code, the 
          compiler will see that the array is of size 10 and not MAX_BUFFER_SIZE because the preproccessor substituted the macro with its value.    
        </aside>
      </section>
      <section>
        <h2>Preprocessor Madness</h2>
        <pre><code class = "c">#include "include.h"

#include "declare_main.h"
#include "open_bracket.h"
#include "print_hello.h"
#include "close_bracket.h"
</code></pre>
        <p>Each "header" file contains a line of C code</p>
        <pre><code class = "c">#include &lt;stdio.h&gt;
void main()
{
  printf("Hello World\n");
}</code></pre>
      <aside class="notes">The Preprocessor madness is an example I came up with to illustrate how the preprocessor can expand code and substitute text. Let's say we have a file 
        where it only contains include directives to other files where each header file contains a line of C code. When the preprocessor processes the source code, it'll give you a 
        normal hello world program.
      </aside>
      </section>
      <section data-background="https://raw.githubusercontent.com/zakuArbor/blog/master/assets/programming/builds/preprocessor_madness.gif">
      <aside class="notes">Here's the demo of the preprocessor madness example.</aside>
      </section>      
      <section>
        <h3>Conditional Macros</h3>
        - You can choose which source code will be compiled -
        <aside class="notes">...</aside>
      </section>
      <section>
        <small>
          No more copies of files that does essentially the same thing 
          with slight differences
        </small>
          <pre><code class = "c">
            #ifdef DEBUG
            printf("File: %s on line %d", __FILE, __LINE);
            printf("Value of x: %d\n", x);
            #endif
          </code></pre>
          <small>
            If we compile code with <code>-DDEBUG</code>, the print statements will be 
            generated in the file the compiler processes
          </small>
          <aside class="notes">
            It's quite often that we want to have slightly different variation of our code for different use cases such as having a lot of print statements to help make debugging 
            easier. But it's not something you wish to expose to the clients or there's some feature that is under development that is not ready yet so you wish to turn the feature off, 
            or the feature only works on certain devices such as on mac but not on windows yet.
            One way to do this is to use conditional macros. It helps reduce making copies of files that does essentially the same thing but with very slight differences.
            
            In the example I am showing, if we compile .. 
          </aside>
      </section>
      <section>
        Great for supporting multiple platforms
        <small><b>Example:</b> nodejs/node/deps/uv/test/test-poll.c</small>
        <p>
        <img src = "https://raw.githubusercontent.com/zakuArbor/blog/master/assets/programming/builds/nodejs-macro.png"/>
        </p>
        <aside class="notes">
          As you can imagine, conditional macros are great for supporting multiple platforms. Here's an example from nodejs runtime that can be found on github.
          They use conditional directives to include certain libraries which differs depending on the targed platform. [go over the code briefly]
        </aside>
      </section>
      <section>
        <h3>Include Directive</h3>
      </section>
      <section>
        <pre>
<code class = "c" data-line-numbers>#include &lt;stdio.h&gt;
int main() {
  printf("Hello World\n");
  return 0;
}</code></pre>
        <small>After preprocessing, the code becomes 720 lines from 5 lines!!!</small><br/>
        <small>75B Source Code to 15.6KB</small>
        <pre><code class="c" data-trim data-noescape data-line-numbers="0|407|620|717"># 1 "main.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "<command-line>" 2
# 1 "main.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 428 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 442 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 443 "/usr/include/sys/cdefs.h" 2 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 444 "/usr/include/sys/cdefs.h" 2 3 4
# 429 "/usr/include/features.h" 2 3 4
# 452 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 453 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-redhat-linux/8/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-redhat-linux/8/include/stddef.h" 3 4

# 216 "/usr/lib/gcc/x86_64-redhat-linux/8/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-redhat-linux/8/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-redhat-linux/8/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 140 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 141 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4
# 52 "/usr/include/stdio.h" 3 4
typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 77 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 173 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) ;
# 187 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 279 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
# 292 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 379 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 409 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 434 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 457 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 491 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 516 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 527 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 543 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 609 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 679 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 713 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 737 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 763 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);





# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 788 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 806 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 846 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 864 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 879 "/usr/include/stdio.h" 3 4

# 2 "main.c" 2


# 3 "main.c"
int main () {
  printf("Hello World\n");
  return 0;
}</code></pre>
      <aside class="notes">
        Using libraries are very normal in programming and this is especially true in C.
        If you have programmed in C, you'll be familiar with the fact that we need to include libraries such as Standard input/output library to work on anything tangible.
        Although writing a hello world program can take about 5 lines of code, what your compiler sees is a totally different file from how you see it.
        If we were to run the preprocessor, the code becomes 720 lines which is way more than the 5 lines we wrote. This is very noticeable if we were to check the file size as well.
      </aside>
      </section>
      <section>
        Include Directive inserts the contents of the header files to the source code
        <p><small>What you are seeing is all the function declarations from stdio.h library</small></p>
        <small>
          <b>Note:</b> 
          Declaration is telling the compiler the existence of identifiers (i.e. functions) 
          without the complete definition/implementation.
        </small>
        <aside class="notes">
          You may be thinking what's going on. I only wrote 5 lines so how can the file the compiler sees be about 144x larger. It turns out the ...
        </aside>
      </section>
    </section>

    <section>
      <section>
        <h2>Compiler</h2>
        - Translates C code to Assembly - 
        <img src = "https://raw.githubusercontent.com/zakuArbor/blog/3629c04cab2406113320382858f05716a2eb0540/assets/programming/builds/gcc-compile.png"/>
        <aside class="notes">
          The step after the preprocessor is the compilation stage which is probably the step you are most familiar with. It translates C code into Assembly.
        </aside>
      </section>
      <section>
        <pre><code class = "c">
          #include &lt;stdio.h&gt;
          int main() {
            printf("Hello World\n");
            return 0;
          }
        </code></pre>
        <small><b>Becomes</b></small>
        <pre><code class = "x86asm" data-line-numbers="1|20">
          .file   "main.c"
          .text
          .section        .rodata
  .LC0:
          .string "Hello World"
          .text
          .globl  main
          .type   main, @function
  main:
  .LFB0:
          .cfi_startproc
          pushq   %rbp
          .cfi_def_cfa_offset 16
          .cfi_offset 6, -16
          movq    %rsp, %rbp
          .cfi_def_cfa_register 6
          movl    $.LC0, %edi
          call    puts
          movl    $0, %eax
          popq    %rbp
          .cfi_def_cfa 7, 8
          ret
          .cfi_endproc
  .LFE0:
          .size   main, .-main
          .ident  "GCC: (GNU) 8.3.1 20191121 (Red Hat 8.3.1-5)"
          .section        .note.GNU-stack,"",@progbits

        </code></pre>
        <aside class="notes">
          If we were to compile a hello world program, we get the following assembly code.
        </aside>
      </section>
    </section>

    <section>
      <section>
        <h2>Assembler</h2>
        - Converts Assembly to Object Files - 
        <img src = "https://raw.githubusercontent.com/zakuArbor/blog/3629c04cab2406113320382858f05716a2eb0540/assets/programming/builds/gcc-assembler.png"/>
        <aside class = "notes">
          However, your computer does not understand assembly code. Your cpu only understands 1s and 0s. Assembly is just a mnemonic language that is supposedly readable to humans.
          We need to translate assembly code into binary code which consists of 1s and 0s. And this is what the role of the assembler is.
        </aside>
      </section>
      <section>
        <h2>Object Files</h2>
        <p>- 3 MAIN TYPES: - </p>
        <ul>
          <li>Shared Object File</li>
          <li>Relocatable Object File</li>
          <li>Executable Object File</li>
        </ul>
        <p>The file generated from the assembler is a <b>RELOCATABLE OBJECT FILE</b></p>
        <aside class="notes">
          Object files are just binary files but there are three different types of object files: ... 
          In our case, the file generated from the assembler ...
        </aside>
      </section>
      <section>
        <p>Not Executable even though file is in binary</p>
        <pre><code class="shell">$ gcc -c test.c -o test.o
$ chmod +x test.o
$ ./test.o
-bash: ./test.o: cannot execute binary file: Exec format error </code></pre>
        <aside class="notes">
          A Relocatable object file is not executable ... 
          Here's what it would like if you were to try to run a Relocatable object file. You'll get an exec format error.
          A rel object file isn't complete in the sense that it's not formatted in a way that your computer understands. Even if your code is formatted in a way that 
          your computer can understand, it contains symbol references (which are variables and functions) not defined in the file itself and therefore incomplete.
          That's where the linker, the next stage after the assembling stage, comes into play.
        </aside>
      </section>
    </section>
    <section>
      <section>
        <h2>Linker</h2>
        <p>Combines multiple object files into one executable file</p>
        <img src = "https://raw.githubusercontent.com/zakuArbor/blog/3629c04cab2406113320382858f05716a2eb0540/assets/programming/builds/gcc-linker.png"/>
        <aside class = "notes">
          The Linker combines ... 
          It's responsible for patching all the undefined symbols that exist in each translation unit.
        </aside>
      </section>
      <section>
      <div style = "background-color: white">
      <img src = "https://www.webopedia.com/wp-content/uploads/2020/10/link_5f854d22127de-2.gif"/>
      </div>
      <aside class = "notes">
        Here's a good image I found on the internet how the linkers work. It essentially combines all the resulting object file from each translation unit into one larger file 
        that is executable. Ignore the runtime library, I won't be going into that but you'll see it in the example later on 
        (i.e. crt0 is a set of execution startup routines linked into a c program)
        Just understand that the linker is needed to create an executable program.
      </aside>
      </section>
      <section>
	<h2>main.c</h2>
	<pre><code class = "c" data-line-numbers="4,5">  void honk();
  void meow();
  int main() {
    honk();
    meow();
    return 0;
  }	</code></pre>
      <p><b><code>honk</code></b> and <b><code>meow</code></b> are not defined in <b>main.c</b></p>
      <p>How does <b>main.c</b> know about these two functions?</p>
      <aside class = "notes">
        In main.c, we have the following code. In line 4 and 5, we call the function honk and meow but those two functions are not defined in the file. So how does the compiler know 
        about these two functions when we never wrote the code for both honk and meow?
      </aside>
      </section>
    <section>
      <h2>main.c</h2>
      <pre><code class = "c" data-line-numbers="1,2">  void honk();
  void meow();
  int main() {
    honk();
    meow();
    return 0;
  } </code></pre>
      <p>The functions have to be <b>declared</b> to tell the compiler they exist</p>
      <p><b>honk</b> and <b>meow</b> are defined in other source files</p>
      <aside class = "notes">
      Frankly the compiler does not need to know how the functions are defined. All it needs is for the functions to be declared to tell the compiler they exist.
      The implementation of honk and meow are defined in other source files.
      </aside>
      </section>
      <section>
        <b>goose.c</b>
        <pre><code class = "c" data-trim >#include &lt;stdio.h&gt;
#define PI 3.14
#define Square(x) ((x)*(x))
void honk() {
    double area = PI * Square(9); //area = pi * r^2
    printf("The Goose Honks the area of the circular pond: %.2f m^2\n", a);
}</code></pre>
        <b>cat.c</b>
        <pre><code class = "c" data-trim>#include &lt;stdio.h&gt;
  void meow() {
  printf("The Cat Meows\n");
}</code></pre>
      <aside class = "notes">
      Here are the implementations of honk and meow respectively.
      </aside>
      </section>
    </section>

  <section>
    <section>
      <h2>Example</h2>
      <img src = "https://raw.githubusercontent.com/zakuArbor/blog/master/assets/programming/builds/code-example-diagram.png"/>
      <aside class = "notes">
      Let's now go through an example to review what I have covered so far.
      </aside>
    </section>
    <section>
      <small style="margin-top:10px;"><b>main.c</b></small>
<pre style = "margin: 0px auto !important;font-size: 16px;"><code class = "c" data-line-numbers="1,2">void honk();
void meow();
int main() {
  honk();
  meow();
  return 0;
} </code></pre>

      <small style="margin-top:10px;"><b>goose.c</b></small>
      <pre style = "margin: 0px auto !important; font-size: 16px;"><code class = "c" data-trim data-line-numbers="4">#include &lt;stdio.h&gt;
#define PI 3.14
#define Square(x) ((x)*(x))
void honk() {
    double area = PI * Square(9); //area = pi * r^2
    printf("The Goose Honks the area of the circular pond: %.2f m^2\n", a);
}</code></pre>
      <small style="margin-top:10px;"><b>cat.c</b></small>
      <pre style = "margin: 0px auto !important;font-size: 16px;"><code class = "c" data-trim data-line-numbers="2">#include &lt;stdio.h&gt;
  void meow() {
  printf("The Cat Meows\n");
}</code></pre>
    <aside class = "notes">This is the entire program. Let's now go through each step in the gcc toolchain.</aside>
    </section>
    <section>
      <h2>Preprocessor</h2>
      <b>gcc -E &lt;file.c&gt;</b>
      <img src = "https://raw.githubusercontent.com/zakuArbor/blog/master/assets/programming/builds/preprocessor_demo.gif"/>
      <aside class = "notes">
      The first step of the toolchain is the preprocessor. We can see the output of the preprocessor if we use "-E" option. In the left side, we can see the original code
      and on the right the output of the preprocessor. As you can see, the file has been expanded to include all the contents of stdio and the macros Square and Pi substituted to 9*9 and 3.14
      </aside>
    </section>
    <section data-background="https://raw.githubusercontent.com/zakuArbor/blog/master/assets/programming/builds/preprocessor_demo.gif">
    </section>
    <section>
      <h2>Compilation and Assembler</h2>
      <b>gcc -c &lt;file.c&gt;</b>
      <br/>
      Could compile separately <b>gcc -S &lt;file.c&gt;</b> and use <b>as</b> for the assembler as well
      <aside class = "notes">
      The next step is the compilation and assembly stage. I'm just going to combine the two steps together but we could perform the steps separately.
      </aside>
    </section>
		<section data-auto-animate>
			<pre data-id="code-animation"><code class="shell" data-trim data-line-numbers="1|2,3">$ gcc -c main.c cat.c goose.c
$ ls *.o
cat.o goose.o main.o
			</code></pre>
      <p><b>gcc -c</b> does preprocessing, compilation, and assembling</p>
		</section>
    <section>
      <h2>Steps So Far</h2>
      <p>main.c &rArr; main.i &rArr; main.s &rArr; main.o</p>
    </section>
    <section data-background="https://raw.githubusercontent.com/zakuArbor/blog/master/assets/programming/builds/compilation_demo.gif"> 
            <aside class = "notes">
                As you can see from the timestamps, it creates a c file, then an i file which is the extension from the preprocessor, and the s file is the assembly file generated during compilation
                and the o file is the output from the assembler
            </aside>
    </section>
    <section>
    <pre style="width: 100% !important;" data-id="code-animation"><code class="shell" data-noescape>$ readelf --syms main.o | grep -E "honk|meow"
     9: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  <font color="#EF2929"><b>UND</b></font> <font color = "#a6e22e"><b>honk</b></font>
    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  <font color="#EF2929"><b>UND</b></font> <font color="#a6e22e"<b>meow</b></font></code></pre>
    <p style = "font-size:0.6em"><b>Notice: Object file has absolutely no clue where and what <b>honk</b> &amp; <b>meow</b></b> are. Hence it appears as <font color="#EF2929"><b>UND</b></font> in the symbol table</p>
    <aside class = "notes">
            If we take a look at the resulting object file, we can see that the two functions honk and meow are undefined. The object ...
    </aside>
    </section>
    <section>
      <h2>Linkers to the rescue</h2>
      <small><b>Linkers connect the missing pieces</b></small>
      <aside class = "notes">
        This is where the linkers come to the rescue. Linkers connects the missing pieces of the program together.
      </aside>
    </section>
    <section>
      <img height="400px" src = "https://github.com/zakuArbor/blog/blob/master/assets/programming/builds/linker-demo.png?raw=true"/>
      <br/>
      <small><b>Simple Idea:</b> ld cat.o goose.o main.o</small><br/>
      <small><b>Actual Command:</b></small>
      <pre style="font-size: 10px; margin: -10px !important;"><code class = "shell" data-line-numbers="3,5">ld /usr/lib64/crti.o /usr/lib64/crtn.o /usr/lib64/crt1.o \ 
&gt;/usr/lib64/libc.so \
&gt;cat.o goose.o main.o 
&gt;-dynamic-linker /lib64/ld-linux-x86-64.so.2 \
&gt;-o prog</code></pre>
      <aside class = "notes">
      The simple idea is that we run the linker ld with all the object files generated during the build to create one executable file. The actual command is a lot more complex than this but let's
      not get into that.
      </aside>
    </section>
    <section>
      <h2>Execute and Run</h2>
      <pre><code class = "shell">$ ./prog
The Goose Honks the area of the circular pond: 254.34 m^2
The Cat Meows
</code></pre>
    <aside class = "notes">With the linking stage completed, we now have an executable that we can run which prints out the goose honks and the cat meows.</aside>
    </section>
  </section>
  <section>
    <section>DEMO SUMMARY</section>
    <section>
      <pre><code class = "shell">$ gcc cat.c goose.c main.c -o prog</code></pre>
      <h4>to</h4>
      <pre><code class = "shell" data-line-numbers="1-3|4-6|7-9|10-14">$ gcc -E main.c -o main.i
$ gcc -E cat.c -o cat.i
$ gcc -E goose.c -o goose.i
$ gcc -S main.i -o main.s
$ gcc -S cat.i -o cat.s
$ gcc -S goose.i -o goose.s
$ as main.s -o main.o
$ as cat.s -o cat.o
$ as goose.s -o goose.o
$ ld /usr/lib64/crti.o /usr/lib64/crtn.o /usr/lib64/crt1.o \
/usr/lib64/libc.so \
cat.o goose.o main.o \
-dynamic-linker /lib64/ld-linux-x86-64.so.2 \
-o prog</code></pre>
      <aside class = "notes">
              To summarize the demo, when you compile the code using gcc or the play button, it's actually doing a lot of step. Firstly it expands the files through the preprocessor creating i files,
              then it goes through the compilation stage where the C code becomes assembly code. As soon as this is done, it'll create object files by assembling each file translating it from assembly 
              to binary. The final step of the build is to link all the object files into one executable file with the linker ld. That's essentially all the steps when you run gcc. Of course, there's 
              more technicalities we could dive into but that's just going to the rabbit hole.
      </aside>
    </section>
  </section>
  <section>
	  <h2>Quick Overview of Static Libraries and Dynamic Libraries</h2>
  </section>
  <section>
    <p>
    In software development, it's very normal for different programs/projects to share the same functions
    <p/>
    <br/>
    <p>
    <b>Example:</b> printf, sqrt, cos, fopen
    </p>
  </section>
  <section>
    <p>Libraries allow programmers to reuse common functions among different projects and programs</p>   
  </section>
  <section>
    <p>This saves development time and prevent reventing the wheel</p>
    <p>Have a consistent and reliable set of functions with defined behavior</p>
  </section>
  <section>
    <h2>Library Examples</h2>
    <ul>
            <li>DirectX SDK (Microsoft's Multimedia API used frequently by Videogame Programmers</li>
            <li>libc (Standard C library)</li>
            <li>asio (C++ Library for network and Low-level I/O programming)</li>
            <li>GTK (GNOME GUI Library) or Qt (another GUI library)</li>
    </ul>
  </section>
  <section>
  <section>
          <h2>Static Libraries (*.a files)</h2>
          <p>Static Librares (known as <b>archives</b> are collection of object files</p>
          <p>Like archiving files (i.e. zipping files), multiples files become one larger file</p>
  </section>
    <section>
          <img src = "https://github.com/zakuArbor/blog/blob/master/assets/programming/builds/static-lib-demo.png?raw=true"/>
          <small>The image is incorrect. It should be archiver and not a linker.</small>
          <aside class = "notes">
          Here's an idea of a static library that can be created using some tool. We combine the object files rabbit, goose, and cat into one larger file named animal. The image is incorrect, it 
          shouldn't be a linker over there but the archiver tool.
          </aside>
  </section>

  <section>
    <pre><code class = "shell" data-line-numbers="1,2|3,4">$ ls *.o
cat.o goose.o main.o
$ ar -rs libanimal.a cat.o goose.o
ar: creating animal.a
</code></pre>
To see what files compose <b>libanimal.a</b>
<pre><code class = "shell" data-line-numbers="1|2,3">$ ar -t libanimal.a
cat.o
goose.o</code></pre>
  <aside class = "notes">
  We have 2 object files we wish to combine into a larger file. We use an archiver ar to create animal as I said in the previous slides. 
  To see the content of the files, we can run the archiver with -t option
  </aside>
  </section>
  <section>
          <pre><code class = "shell" data-line-numbers="1|2-4">$ gcc main.o -L. -lanimal -o prog2
$ ./prog2
The Goose Honks the area of the circular pond: 254.34 m^2
The Cat Meows</code></pre>
    <aside class = "notes">
            Let's replicate the demo I presented earlier where I compiled main.c, cat.c, and goose.c.
            Since libanimal.a contains both goose.o and cat.o, we can simply link it with main.o 
            using gcc with -L. to specify the library directory to be in the current directory and -lanimal, the static library we made without the prefix lib and extension .a
            As you can see we get the same result as before
    </aside>
  </section>
  <section>
    <h2>Benefits</h2>
    <ul>
      <li>If multiple components or projects use the same set of libraries, no need to recompile</li>
      <li>Saves compilation time, compile once and link it each time</li>
    </ul>
  </section>
  </section>
  <section>
    <section>
      <h2>Dynamic Libraries (*.so)</h2>
      <p>Also known as <b>SHARED LIBRARIES</b></p>
      <small>*.dll on Windows</small>
    </section>
    <section>
      <p>
      Unlike previous examples where we link object files to create an executable program (BEFORE RUNNING THE PROGRAM), </p><br/>
      <p>
      dynamic libraries are linked during <b>RUNTIME</b> whenever we run the program
      </p>
    </section>
    <section>
      <p>As the name implies, dynamic libraries are loaded and linked during RUNTIME</p> 
      <p>
      The other name, <b>shared library</b> has a reason, it means multiple programs share the 
      same library in memory by linking to it
      </p>
    </section>
    <section>
      <h2>How I imagine it</h2>
      <img src = "https://raw.githubusercontent.com/zakuArbor/blog/f2afcfe49b6d56fe8c472def251f649baac433c0/assets/programming/builds/shared-lib-imagine.png"/>
      <aside class = "notes">
      Here's how I imagine how the dynamic linker works. We have two programs, program1 and program2 loaded into memory. When they want to call printf, the program will jump to somewhere in memory 
      where print is located in memory. So if program 2 wants to call printf or malloc as well, it'll call the function from the same address as program1 used.
      </aside>
    </section>
    <section>
      <h2>Benefits</h2>
      <ul>
              <li>Executable is smaller because definition isn't in the executable itself (i.e. the code for the libraries are stored in the computer at some common location such as <b>/usr/lib</b></li>
              <li>All programs using the library just need to link to the definition loaded in memory</li>
              <li>Easy to update if a bug exists</li>
      </ul>
    </section>
    <section>
      <h2>LDD - See object Dependencies</h2>
      <pre><code class = "shell" style="font-size: 0.7em;" data-trim>$ ldd /bin/ls
	linux-vdso.so.1 (0x00007fff41141000)
	libselinux.so.1 => /lib64/libselinux.so.1 (0x00007f11d1688000)
	libcap.so.2 => /lib64/libcap.so.2 (0x00007f11d1482000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f11d10bf000)
	libpcre2-8.so.0 => /lib64/libpcre2-8.so.0 (0x00007f11d0e3b000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007f11d0c37000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f11d1ad5000)
	libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f11d0a17000)
      </code></pre>
      <aside class = "notes">ldd is a nice tool that let's us know the dependencies of a program. This is very helpful when debugging unexpected program behaviors.</aside>
    </section>
    <section>
            <b>demo Program</b>
                <pre><code class = "shell" style="font-size: 0.7em;" data-line-numbers="2-5" data-noescape>$ ldd prog
  <b>linux-vdso.so.1</b> (0x00007ffe18950000)
  <b>libc.so.6</b> =&gt; /lib64/libc.so.6 (0x00007f8c50cb4000)
  <b>/lib64/ld-linux-x86-64.so.2</b> (0x00007f8c51077000)
      </code></pre>
      <b>LS Utility</b>
          <pre><code class = "shell" style="font-size: 0.7em;" data-line-numbers="2,5,8" data-noescape>$ ldd /bin/ls
  <b>linux-vdso.so.1</b> (0x00007fff41141000)
  libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f11d1688000)
  libcap.so.2 =&gt; /lib64/libcap.so.2 (0x00007f11d1482000)
  <b>libc.so.6</b> =&gt; /lib64/libc.so.6 (0x00007f11d10bf000)
  libpcre2-8.so.0 =&gt; /lib64/libpcre2-8.so.0 (0x00007f11d0e3b000)
  libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f11d0c37000)
  <b>/lib64/ld-linux-x86-64.so.2</b> (0x00007f11d1ad5000)
  libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f11d0a17000)
      </code></pre>
      <small>Since ASLR is enabled, the addresses are not the same but would be if we disabled ASLR. ASLR is some memory protection techinque that randomize the positions of programs and libraries</small>
      <aside class = "notes">If we were to compare between our demo and ls, a unix utility, we can see common libraries that are shared between the two programs. Since ASLR is enabled ...</aside>
    </section>
  </section>
  <section>
    <section><h2>STATIC V.S DYNAMIC LIBRARIES</h2></section>
    <section>
      <h2>STATIC LIBRARIES CONS</h2>
      <ul>
        <li>generate bigger executable files since library is integrated inside executable</li>
        <li>less memory efficient - each program has their own copy of the library</li>
        <li>Not easy to update - Requires all programs to update their copy of the library if a bug exists</li>
      <ul>
    </section>
    <section>
            <h2>Drawback of Dynamic Libraries</h2>
            <ul>
                    <li>Since many programs link to the same library, can cause compatibility issues if library gets updated or removed</li>
                    <li>Extremely annoying to install programs</li>
            </ul>
            <img src = "https://www.personalcomputerfixes.com/wp-content/uploads/2011/05/d3dx9-not-found.jpg">
    <aside class="notes">when building open source programs, it may fail because you are missing some packages</aside>
    </section>
    <section>
            <h2>Interesting Example</h2>
            <b>expr</b> evaluates expression (i.e. a calculator)
            <pre><code class = "shell">$ expr 2 \* 2
4</code></pre>
    <aside class = "notes">
            Here's an interesting example, one time I was using the expr utility to do some calculations because I was too lazy to get a open the calculator app. 
            expr for those who don't know, it's like a calculator but on the terminal.
    </aside>
    </section>
    <section>
      <p>What happens if the library used by expr is corrupted?</p>
      <pre><code>$ expr 2 \* 2
8589934592</code></pre>
      <aside class = "notes">But when I was punching in some numbers, it gave me some bizzare number such as what you see in the screen. This was on one of our build machines. ppcle08</aside>
    </section>
    <section>
    <p>A pseudo install of a program contained <b>libgmp</b> which caused an issue</p>
    <pre><code class = "shell" data-line-numbers="3" data-noescape style = "font-size: 0.75em;">$ ldd `which expr`
  linux-vdso64.so.1 =&gt; (0x0003fff9d4800000)
  libgmp.so.10 &gt; /home/user/<b>program</b>/lib/libgmp.so.10 (0x00003fff9df00000)
  libc.so.6 =&gt; /lib64/power8/libc.so.6 (0x00003fff9d200000)
  /lib64/ld64.so.2 (0x00000000749a0000)</code></pre>
    <small>Still not sure why the program gives an unexpected output because the differences in version should not matter</small>
    <aside class = "notes">
            So I quickly try to debug the program and in the end found out that the shared library it was using wasn't the one installed on the computer but was contained in a pseudo install of a 
            program under home.
    </aside>
    </section>
  </section>
  <section><h1>FIN</h1>
  </section>
	</div>

</div>

<script src="dist/reveal.js"></script>
<script src="plugin/zoom/zoom.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/search/search.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>

	// Also available as an ES module, see:
	// https://revealjs.com/initialization/
	Reveal.initialize({
		controls: true,
		progress: true,
		center: true,
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
	});

</script>

	</body>
</html>
